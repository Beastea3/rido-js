var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { idlFactory } from "./did/II";
import { Actor, HttpAgent } from "@dfinity/agent";
import { sha256 } from "js-sha256";
export function fromHexString(hexString) {
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))).buffer;
}
const ii_cid = 
// "rwlgt-iiaaa-aaaaa-aaaaa-cai"
"h3id2-uqaaa-aaaao-ajjoa-cai";
export class II {
    constructor(identity) {
        this.identity = identity;
    }
    getActor() {
        return __awaiter(this, void 0, void 0, function* () {
            const agent = new HttpAgent({
                identity: this.identity,
                host: "https://ic0.app"
            });
            return Actor.createActor(idlFactory, {
                agent,
                canisterId: ii_cid,
            });
        });
    }
    get_pubKey_json() {
        return this.identity.toJSON();
    }
    get_pubKey() {
        return this.identity.getPublicKey();
    }
    prepare_delegation(address, json_pub_key, sig, maxTimeToLive) {
        return __awaiter(this, void 0, void 0, function* () {
            const Actor = yield this.getActor();
            const arg = [address.slice(2), json_pub_key, sig];
            const res = yield Actor.prepare_delegation([maxTimeToLive], arg);
            return yield this.get_delegation(address, res);
        });
    }
    get_delegation(address, arg) {
        return __awaiter(this, void 0, void 0, function* () {
            const Actor = yield this.getActor();
            const array = fromHexString(address.slice(2));
            const seed = sha256.digest(array);
            const callBack = () => __awaiter(this, void 0, void 0, function* () {
                return yield Actor.get_delegation(seed, [...new Uint8Array(this.get_pubKey().toDer())], arg[1]);
            });
            const signed_delegation = yield retryGetDelegation(callBack);
            const c = [
                [...arg[0]],
                {
                    delegation: {
                        pubkey: Uint8Array.from(signed_delegation.delegation.pubkey),
                        expiration: BigInt(signed_delegation.delegation.expiration),
                        targets: undefined,
                    },
                    signature: Uint8Array.from(signed_delegation.signature),
                },
            ];
            const [userKey, parsed_signed_delegation] = c;
            const d = {
                delegations: [parsed_signed_delegation],
                userPublicKey: Uint8Array.from(userKey)
            };
            return d;
        });
    }
}
const retryGetDelegation = (callback, maxRetries = 5) => __awaiter(void 0, void 0, void 0, function* () {
    for (let i = 0; i < maxRetries; i++) {
        // Linear backoff
        yield new Promise((resolve) => {
            setInterval(resolve, 1000 * i);
        });
        const res = yield callback();
        if ("signed_delegation" in res) {
            return res.signed_delegation;
        }
    }
    throw new Error(`Failed to retrieve a delegation after ${maxRetries} retries.`);
});
